"""
0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

示例 1：

输入: n = 5, m = 3
输出: 3
示例 2：

输入: n = 10, m = 17
输出: 2
 

限制：

1 <= n <= 10^5
1 <= m <= 10^6

这个问题是以弗拉维奥·约瑟夫命名的，他是1世纪的一名犹太历史学家。
他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。
他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。
约瑟夫斯和另外一个人是最后两个留下的人。
约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。
约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。 
—— 【约瑟夫问题】维基百科

作者：sweetieeyi
链接：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/javajie-jue-yue-se-fu-huan-wen-ti-gao-su-ni-wei-sh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
"""

# f(n)是从0开始数的， 可以看成，'f(n-1)' 从 '(m+x)%n' 开始数。
# f(n-1,m) = x 是n-1的序列最后留下第x个数。
# 那么f(n,m)会先删掉第m%n的数，成为一个从n%m开始数的n-1的序列
# so：
# f(n,m) = (m%n + f(n-1,m))%n = (m + f(n-1,m))%n

class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        f = 0
        for i in range(2, n + 1):
            f = (m + f) % i
        return f
